<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>55Guh</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #0b0f12;
      color: #e6edf3;
      margin: 18px;
    }
    a { color: #6bd1ff; text-decoration: none; cursor: pointer; }
    a:hover { text-decoration: underline; }
    button { margin: 6px 6px 6px 0; }
    #progressContainer { margin-top: 12px; display:none; }
    #progressBar { width: 100%; height: 18px; }
    ul { padding-left: 0; list-style: none; }
    li { margin: 6px 0; }
    #breadcrumbs { margin-bottom: 8px; color: #9fb7c7; }
    .muted { color: #8aa3b4; }
  </style>
</head>
<body>
  <h2>55Guh</h2>
  <div id="breadcrumbs"></div>
  <div id="fileList"></div>

  <div id="progressContainer">
    <p class="muted">üì¶ Building ZIP ‚Äî please wait</p>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>

  <!-- JSZip + FileSaver -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
    const user = "55guh";
    let currentRepo = null;
    let currentPath = "";
    let historyStack = [];

    // List user repos (initial view)
    async function listRepos() {
      currentRepo = null;
      currentPath = "";
      updateBreadcrumbs();

      const container = document.getElementById("fileList");
      container.innerHTML = "<h3>Select a repo:</h3><ul id='repos'></ul>";
      const ul = document.getElementById("repos");

      try {
        const res = await fetch(`https://api.github.com/users/${user}/repos`);
        if (!res.ok) {
          container.innerHTML = `<p>Failed to load repos: ${res.status} ${res.statusText}</p>`;
          return;
        }
        const repos = await res.json();
        repos.forEach(r => {
          const li = document.createElement("li");
          const a = document.createElement("a");
          a.textContent = "üì¶ " + r.name;
          a.href = "#";
          a.addEventListener("click", (e) => {
            e.preventDefault();
            openRepo(r.name, "");
          });
          li.appendChild(a);
          ul.appendChild(li);
        });
      } catch (err) {
        container.innerHTML = `<p>Error: ${err.message}</p>`;
      }
    }

    // Open a repo / folder
    async function openRepo(repo, path = "", fromHistory = false) {
      // push current state to history (unless coming from history navigation or initial)
      if (!fromHistory && currentRepo !== null) {
        historyStack.push({ repo: currentRepo, path: currentPath });
      }

      currentRepo = repo;
      currentPath = path;
      updateBreadcrumbs();

      const container = document.getElementById("fileList");
      container.innerHTML = `
        <h3>Browsing: ${repo}/${path}</h3>
        <button id="backBtn">‚¨Ö Go Back</button>
        <button id="repoZipBtn">üì¶ Download This Folder as ZIP</button>
        <ul id="items"><li class="muted">Loading...</li></ul>
      `;

      document.getElementById("backBtn").addEventListener("click", () => goBack());
      document.getElementById("repoZipBtn").addEventListener("click", () => {
        downloadFolderAsZip(repo, path);
      });

      // fetch contents from GitHub API
      try {
        const apiUrl = getApiUrl(repo, path);
        const res = await fetch(apiUrl);
        if (!res.ok) {
          const text = await res.text();
          document.getElementById("items").innerHTML =
            `<li>‚ùå Failed to load folder: ${res.status} ${res.statusText}</li>`;
          return;
        }
        const items = await res.json();

        // If GitHub sends an object with message (rate limit / error), show it
        if (items && items.message) {
          document.getElementById("items").innerHTML = `<li>‚ùå ${items.message}</li>`;
          return;
        }

        const ul = document.getElementById("items");
        ul.innerHTML = "";

        // directories
        items.filter(it => it.type === "dir").forEach(d => {
          const li = document.createElement("li");
          li.textContent = "üìÇ " + d.name + " ";

          const browse = document.createElement("a");
          browse.href = "#";
          browse.textContent = "[Browse]";
          browse.addEventListener("click", (e) => {
            e.preventDefault();
            openRepo(repo, path + d.name + "/");
          });

          const zip = document.createElement("a");
          zip.href = "#";
          zip.textContent = " [ZIP]";
          zip.style.marginLeft = "8px";
          zip.addEventListener("click", (e) => {
            e.preventDefault();
            downloadFolderAsZip(repo, path + d.name + "/");
          });

          li.appendChild(browse);
          li.appendChild(zip);
          ul.appendChild(li);
        });

        // files
        items.filter(it => it.type === "file").forEach(f => {
          const li = document.createElement("li");
          li.textContent = "üìÑ " + f.name + " ";

          const a = document.createElement("a");
          a.href = f.download_url;
          a.textContent = "[Download]";
          a.setAttribute("download", f.name);

          li.appendChild(a);
          ul.appendChild(li);
        });

        // if folder empty
        if (items.length === 0) {
          document.getElementById("items").innerHTML = "<li class='muted'>This folder is empty.</li>";
        }
      } catch (err) {
        document.getElementById("items").innerHTML = `<li>Error: ${err.message}</li>`;
      }
    }

    // go back in history
    function goBack() {
      if (historyStack.length === 0) {
        // back to repo list
        listRepos();
        return;
      }
      const prev = historyStack.pop();
      // call openRepo with fromHistory=true so it doesn't push again
      openRepo(prev.repo, prev.path, true);
    }

    // Build GitHub API URL ‚Äî special-case GitHub Pages repo -> "file" folder
    function getApiUrl(repo, path = "") {
      if (repo === "55guh.github.io") {
        // we store main/Pages files under "file/" on the repo
        return `https://api.github.com/repos/${user}/${repo}/contents/file/${path}`;
      }
      return `https://api.github.com/repos/${user}/${repo}/contents/${path}`;
    }

    // ZIP builder: in-browser, with progress
    async function downloadFolderAsZip(repo, path = "") {
      const progressContainer = document.getElementById("progressContainer");
      const progressBar = document.getElementById("progressBar");
      progressContainer.style.display = "block";
      progressBar.value = 0;

      const zip = new JSZip();

      // count files first to give progress feedback
      let totalFiles = 0;
      try {
        totalFiles = await countFiles(repo, path);
      } catch (err) {
        totalFiles = 0;
      }

      let processed = 0;
      function onProgress() {
        processed++;
        if (totalFiles > 0) progressBar.value = (processed / totalFiles) * 100;
        else progressBar.value = 100;
      }

      try {
        await addFolderToZip(zip, repo, path, onProgress);
        const folderName = (path === "" ? repo : path.split("/").filter(Boolean).pop());
        const blob = await zip.generateAsync({ type: "blob" }, (meta) => {
          // meta.percent is generation progress, we can combine it for smoother bar
          if (totalFiles === 0) progressBar.value = meta.percent;
        });
        saveAs(blob, folderName + ".zip");
      } catch (err) {
        alert("Failed to build ZIP: " + err.message);
      } finally {
        progressContainer.style.display = "none";
        progressBar.value = 0;
      }
    }

    async function countFiles(repo, path = "") {
      const res = await fetch(getApiUrl(repo, path));
      if (!res.ok) return 0;
      const items = await res.json();
      if (items && items.message) return 0;
      let count = 0;
      for (const it of items) {
        if (it.type === "file") count++;
        else if (it.type === "dir") {
          count += await countFiles(repo, path + it.name + "/");
        }
      }
      return count;
    }

    async function addFolderToZip(zip, repo, path = "", onProgress = () => {}) {
      const res = await fetch(getApiUrl(repo, path));
      if (!res.ok) throw new Error("Failed to fetch folder: " + res.status);
      const items = await res.json();
      if (items && items.message) throw new Error(items.message);

      for (const it of items) {
        if (it.type === "file") {
          const fileRes = await fetch(it.download_url);
          if (!fileRes.ok) throw new Error("Failed to fetch file: " + it.download_url);
          const blob = await fileRes.blob();
          // place file in zip preserving folder structure
          zip.file(path + it.name, blob);
          onProgress();
        } else if (it.type === "dir") {
          // recurse, preserving path prefix
          await addFolderToZip(zip, repo, path + it.name + "/", onProgress);
        }
      }
    }

    // start at repo list
    listRepos();
  </script>
</body>
</html>
